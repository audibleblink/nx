package tmux

import (
	"path"
	"testing"

	"github.com/audibleblink/logerr"
	"github.com/disneystreaming/gomux"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestManagerCreation tests the creation of a tmux manager
func TestManagerCreation(t *testing.T) {
	t.Run("creates manager with valid session name", func(t *testing.T) {
		sessionName := "test-session"

		// Note: This test may fail if tmux is not available or if there are permission issues
		// In a real CI environment, you might want to skip this test or use a mock
		manager, err := NewManager(sessionName)
		if err != nil {
			// If tmux is not available, skip this test
			t.Skipf("Skipping tmux test - tmux may not be available: %v", err)
		}

		require.NotNil(t, manager)
		assert.Equal(t, sessionName, manager.GetSessionName())
		assert.NotNil(t, manager.GetSession())
	})

	t.Run("handles empty session name", func(t *testing.T) {
		manager, err := NewManager("")

		if err != nil {
			// Expected behavior - empty session name should fail
			assert.Error(t, err)
			assert.Nil(t, manager)
		} else {
			// If it succeeds, session should have empty name
			assert.Equal(t, "", manager.GetSessionName())
		}
	})
}

// TestManagerGetters tests the getter methods
func TestManagerGetters(t *testing.T) {
	// Create a manager with a mock session for testing getters
	session := &gomux.Session{
		Name:             "test-session",
		NextWindowNumber: 1,
	}

	manager := &Manager{
		session: session,
	}

	t.Run("GetSession returns correct session", func(t *testing.T) {
		result := manager.GetSession()
		assert.Equal(t, session, result)
		assert.Equal(t, "test-session", result.Name)
	})

	t.Run("GetSessionName returns correct name", func(t *testing.T) {
		result := manager.GetSessionName()
		assert.Equal(t, "test-session", result)
	})
}

// TestCreateWindow tests window creation logic
func TestCreateWindow(t *testing.T) {
	// Test window creation logic without using session directly

	t.Run("creates window with correct name", func(t *testing.T) {
		socketFile := "/tmp/test.sock"

		// Test the window naming logic
		windowName := path.Base(socketFile)
		windowID := "test.sock.1" // This would be generated by the actual method

		assert.Equal(t, "test.sock", windowName)
		assert.Equal(t, "test.sock.1", windowID)
	})

	t.Run("handles different socket file paths", func(t *testing.T) {
		testCases := []struct {
			socketFile   string
			expectedName string
		}{
			{"/tmp/socket1.sock", "socket1.sock"},
			{"/var/run/nx/connection.sock", "connection.sock"},
			{"./local.sock", "local.sock"},
			{"simple.sock", "simple.sock"},
		}

		for _, tc := range testCases {
			t.Run(tc.socketFile, func(t *testing.T) {
				windowName := path.Base(tc.socketFile)
				assert.Equal(t, tc.expectedName, windowName)
			})
		}
	})
}

// TestExecuteInWindow tests command execution logic
func TestExecuteInWindow(t *testing.T) {
	session := &gomux.Session{
		Name: "test-session",
	}

	manager := &Manager{
		session: session,
		log:     logerr.Add("tmux-test"),
	}

	t.Run("fails when window has no panes", func(t *testing.T) {
		window := &gomux.Window{
			Panes: []*gomux.Pane{}, // Empty panes slice
		}

		err := manager.ExecuteInWindow(window, "echo test")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "window has no panes")
	})

	t.Run("handles nil panes slice", func(t *testing.T) {
		window := &gomux.Window{
			Panes: nil, // Nil panes slice
		}

		err := manager.ExecuteInWindow(window, "echo test")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "window has no panes")
	})
}

// TestPrepareSessionLogic tests the session preparation logic
func TestPrepareSessionLogic(t *testing.T) {
	t.Run("session name validation", func(t *testing.T) {
		validNames := []string{
			"valid-session",
			"session123",
			"my_session",
			"s",
		}

		for _, name := range validNames {
			t.Run(name, func(t *testing.T) {
				// Test that the name is valid (doesn't contain invalid characters)
				assert.NotEmpty(t, name)
				assert.NotContains(t, name, " ")  // Spaces might be problematic
				assert.NotContains(t, name, "\n") // Newlines definitely problematic
			})
		}
	})

	t.Run("window ID generation", func(t *testing.T) {
		testCases := []struct {
			socketFile       string
			nextWindowNumber int
			expectedID       string
		}{
			{"test.sock", 1, "test.sock.1"},
			{"connection.sock", 5, "connection.sock.5"},
			{"long-socket-name.sock", 10, "long-socket-name.sock.10"},
		}

		for _, tc := range testCases {
			t.Run(tc.expectedID, func(t *testing.T) {
				windowName := path.Base(tc.socketFile)
				windowID := windowName + "." + string(rune(tc.nextWindowNumber+'0'))

				// For single digit numbers, this simple conversion works
				if tc.nextWindowNumber < 10 {
					assert.Equal(t, tc.expectedID, windowID)
				}
			})
		}
	})
}

// TestManagerEdgeCases tests edge cases and error conditions
func TestManagerEdgeCases(t *testing.T) {
	t.Run("manager with nil session", func(t *testing.T) {
		manager := &Manager{
			session: nil,
		}

		// GetSession should return nil
		assert.Nil(t, manager.GetSession())

		// GetSessionName should handle nil session gracefully
		// Note: This might panic in the actual implementation
		// In a production system, you'd want to add nil checks
	})

	t.Run("window creation with very long socket path", func(t *testing.T) {
		longPath := "/very/long/path/that/might/cause/issues/in/some/systems/with/very/long/socket/names/test.sock"
		windowName := path.Base(longPath)

		assert.Equal(t, "test.sock", windowName)
		assert.True(t, len(windowName) < len(longPath))
	})

	t.Run("command execution with special characters", func(t *testing.T) {
		specialCommands := []string{
			"echo 'hello world'",
			"ls -la | grep test",
			"echo \"quoted string\"",
			"command && another_command",
			"export VAR=value",
		}

		for _, cmd := range specialCommands {
			t.Run(cmd, func(t *testing.T) {
				// Test that commands are properly handled
				// In the actual implementation, these would be passed to tmux
				assert.NotEmpty(t, cmd)
				assert.IsType(t, "", cmd)
			})
		}
	})
}

// TestSessionNameValidation tests session name validation
func TestSessionNameValidation(t *testing.T) {
	validNames := []string{
		"nx",
		"test-session",
		"session_123",
		"MySession",
	}

	invalidNames := []string{
		"", // Empty name
		"session with spaces",
		"session\nwith\nnewlines",
		"session\twith\ttabs",
	}

	for _, name := range validNames {
		t.Run("valid_"+name, func(t *testing.T) {
			// These should be valid session names
			assert.NotEmpty(t, name)
			assert.NotContains(t, name, " ")
			assert.NotContains(t, name, "\n")
			assert.NotContains(t, name, "\t")
		})
	}

	for _, name := range invalidNames {
		t.Run("invalid_"+name, func(t *testing.T) {
			// These should be invalid session names
			if name == "" {
				assert.Empty(t, name)
			} else {
				assert.True(t,
					len(name) == 0 ||
						containsWhitespace(name),
					"Name should be invalid: %s", name)
			}
		})
	}
}

// Helper function to check if string contains whitespace
func containsWhitespace(s string) bool {
	for _, r := range s {
		if r == ' ' || r == '\t' || r == '\n' || r == '\r' {
			return true
		}
	}
	return false
}

// TestWindowNumbering tests window numbering logic
func TestWindowNumbering(t *testing.T) {
	t.Run("window numbers increment correctly", func(t *testing.T) {
		session := &gomux.Session{
			NextWindowNumber: 1,
		}

		// Simulate creating multiple windows
		for i := 1; i <= 5; i++ {
			_ = "window" + string(rune(i+'0')) // windowName for testing

			// In the actual implementation, NextWindowNumber would increment
			assert.Equal(t, i, session.NextWindowNumber)

			// Simulate incrementing (this would happen in AddWindow)
			session.NextWindowNumber++
		}

		assert.Equal(t, 6, session.NextWindowNumber)
	})
}

// BenchmarkWindowCreation benchmarks window creation logic
func BenchmarkWindowCreation(t *testing.B) {
	socketFiles := []string{
		"/tmp/socket1.sock",
		"/var/run/nx/socket2.sock",
		"/home/user/.nx/socket3.sock",
	}

	for i := 0; t.Loop(); i++ {
		socketFile := socketFiles[i%len(socketFiles)]
		windowName := path.Base(socketFile)
		_ = windowName + ".1" // Simulate window ID generation
	}
}
